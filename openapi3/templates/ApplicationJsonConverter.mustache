{{>partial_header}}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace {{packageName}}.Model
{
    /// <summary>
    /// Custom JSON converter for Application that handles the null signOnMode case for Active Directory apps.
    /// 
    /// The Okta API uses signOnMode as the discriminator for Application types:
    /// - "AUTO_LOGIN" → AutoLoginApplication
    /// - "SAML_2_0" → SamlApplication
    /// - "OPENID_CONNECT" → OpenIdConnectApplication
    /// - null → ActiveDirectoryApplication (AD directory integrations have null signOnMode)
    /// </summary>
    public class ApplicationJsonConverter : JsonConverter<Application>
    {
        private static readonly Dictionary<string, Type> SignOnModeMapping = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase)
        {
            { "AUTO_LOGIN", typeof(AutoLoginApplication) },
            { "BASIC_AUTH", typeof(BasicAuthApplication) },
            { "BOOKMARK", typeof(BookmarkApplication) },
            { "BROWSER_PLUGIN", typeof(BrowserPluginApplication) },
            { "OPENID_CONNECT", typeof(OpenIdConnectApplication) },
            { "SAML_1_1", typeof(Saml11Application) },
            { "SAML_2_0", typeof(SamlApplication) },
            { "SECURE_PASSWORD_STORE", typeof(SecurePasswordStoreApplication) },
            { "WS_FEDERATION", typeof(WsFederationApplication) }
        };

        /// <summary>
        /// Writes the JSON representation of the Application object.
        /// </summary>
        public override void WriteJson(JsonWriter writer, Application value, JsonSerializer serializer)
        {
            // Use default serialization for writing, but remove this converter to avoid recursion
            var settings = new JsonSerializerSettings
            {
                ContractResolver = serializer.ContractResolver,
                NullValueHandling = serializer.NullValueHandling,
                Formatting = serializer.Formatting,
                DateParseHandling = serializer.DateParseHandling,
                Converters = serializer.Converters.Where(c => !(c is ApplicationJsonConverter)).ToList()
            };
            
            var token = JToken.FromObject(value, JsonSerializer.Create(settings));
            token.WriteTo(writer);
        }

        /// <summary>
        /// Reads the JSON representation of the Application object, using signOnMode to determine the correct type.
        /// Handles the special case where signOnMode is null (Active Directory applications).
        /// </summary>
        public override Application ReadJson(JsonReader reader, Type objectType, Application existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                return null;
            }

            var jsonObject = JObject.Load(reader);
            
            // Get the signOnMode value to determine the concrete type
            var signOnModeToken = jsonObject["signOnMode"];
            var signOnModeValue = signOnModeToken?.Type == JTokenType.Null ? null : signOnModeToken?.ToString();
            
            // Determine the target type based on signOnMode
            Type targetType;
            
            if (string.IsNullOrEmpty(signOnModeValue))
            {
                // null or empty signOnMode indicates an Active Directory application
                targetType = typeof(ActiveDirectoryApplication);
            }
            else if (SignOnModeMapping.TryGetValue(signOnModeValue, out var mappedType))
            {
                targetType = mappedType;
            }
            else
            {
                // Unknown signOnMode - fall back to base Application type
                targetType = typeof(Application);
            }

            // Create serializer settings without this converter to avoid infinite recursion
            var tempSettings = new JsonSerializerSettings
            {
                ContractResolver = serializer.ContractResolver,
                NullValueHandling = serializer.NullValueHandling,
                DateParseHandling = DateParseHandling.DateTimeOffset,
                Converters = serializer.Converters.Where(c => !(c is ApplicationJsonConverter)).ToList()
            };

            // For the base Application type, use PopulateObject to avoid the [JsonConverter] attribute on the class
            // which would cause infinite recursion
            if (targetType == typeof(Application))
            {
                var app = new Application();
                using (var jsonReader = jsonObject.CreateReader())
                {
                    JsonSerializer.CreateDefault(tempSettings).Populate(jsonReader, app);
                }
                return app;
            }

            // For derived types (which don't have the [JsonConverter] attribute), ToObject works fine
            var tempSerializer = JsonSerializer.CreateDefault(tempSettings);
            return (Application)jsonObject.ToObject(targetType, tempSerializer);
        }
    }
}
