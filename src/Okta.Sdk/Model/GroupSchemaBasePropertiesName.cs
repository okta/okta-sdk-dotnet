// <copyright company="Okta, Inc">
// Copyright (c) 2014-present Okta, Inc. All rights reserved.
// Licensed under the Apache 2.0 license. See the LICENSE file in the project root for full license information.
// </copyright>

/*
 * Okta Admin Management
 *
 * Allows customers to easily access the Okta Management APIs
 *
 * The version of the OpenAPI document: 5.1.0
 * Contact: devex-public@okta.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using OpenAPIDateConverter = Okta.Sdk.Client.OpenAPIDateConverter;

namespace Okta.Sdk.Model
{
    /// <summary>
    /// Template: ModelGeneric
    /// Unique identifier for the group
    /// </summary>
    [DataContract(Name = "GroupSchemaBaseProperties_name")]
    
    public partial class GroupSchemaBasePropertiesName : IEquatable<GroupSchemaBasePropertiesName>
    {

        /// <summary>
        /// Identifies the type of data represented by the string
        /// </summary>
        /// <value>Identifies the type of data represented by the string</value>
        [DataMember(Name = "format", EmitDefaultValue = true)]
        
        public UserSchemaAttributeFormat Format { get; set; }

        /// <summary>
        /// Defines the mutability of the property
        /// </summary>
        /// <value>Defines the mutability of the property</value>
        [DataMember(Name = "mutability", EmitDefaultValue = true)]
        
        public UserSchemaAttributeMutabilityString Mutability { get; set; }

        /// <summary>
        /// Determines whether a group attribute can be set at the individual or group level
        /// </summary>
        /// <value>Determines whether a group attribute can be set at the individual or group level</value>
        [DataMember(Name = "scope", EmitDefaultValue = true)]
        
        public UserSchemaAttributeScope Scope { get; set; }

        /// <summary>
        /// Type of property
        /// </summary>
        /// <value>Type of property</value>
        [DataMember(Name = "type", EmitDefaultValue = true)]
        
        public UserSchemaAttributeType Type { get; set; }
        
        /// <summary>
        /// Description of the property
        /// </summary>
        /// <value>Description of the property</value>
        [DataMember(Name = "description", EmitDefaultValue = true)]
        public string Description { get; set; }

        /// <summary>
        /// Enumerated value of the property.  The value of the property is limited to one of the values specified in the enum definition. The list of values for the enum must consist of unique elements.
        /// </summary>
        /// <value>Enumerated value of the property.  The value of the property is limited to one of the values specified in the enum definition. The list of values for the enum must consist of unique elements.</value>
        [DataMember(Name = "enum", EmitDefaultValue = true)]
        public List<Object> Enum { get; set; }

        /// <summary>
        /// Name of the property as it exists in an external application
        /// </summary>
        /// <value>Name of the property as it exists in an external application</value>
        [DataMember(Name = "externalName", EmitDefaultValue = true)]
        public string ExternalName { get; set; }

        /// <summary>
        /// Namespace from the external application
        /// </summary>
        /// <value>Namespace from the external application</value>
        [DataMember(Name = "externalNamespace", EmitDefaultValue = true)]
        public string ExternalNamespace { get; set; }

        /// <summary>
        /// Gets or Sets Items
        /// </summary>
        [DataMember(Name = "items", EmitDefaultValue = true)]
        public UserSchemaAttributeItems Items { get; set; }

        /// <summary>
        /// Gets or Sets Master
        /// </summary>
        [DataMember(Name = "master", EmitDefaultValue = true)]
        public GroupSchemaAttributeMaster Master { get; set; }

        /// <summary>
        /// Maximum character length of a string property
        /// </summary>
        /// <value>Maximum character length of a string property</value>
        [DataMember(Name = "maxLength", EmitDefaultValue = true)]
        public int? MaxLength { get; set; }

        /// <summary>
        /// Minimum character length of a string property
        /// </summary>
        /// <value>Minimum character length of a string property</value>
        [DataMember(Name = "minLength", EmitDefaultValue = true)]
        public int? MinLength { get; set; }

        /// <summary>
        /// Non-empty array of valid JSON schemas.  The &#x60;oneOf&#x60; key is only supported in conjunction with &#x60;enum&#x60; and provides a mechanism to return a display name for the &#x60;enum&#x60; value.&lt;br&gt; Each schema has the following format:  &#x60;&#x60;&#x60; {   \&quot;const\&quot;: \&quot;enumValue\&quot;,   \&quot;title\&quot;: \&quot;display name\&quot; } &#x60;&#x60;&#x60;  When &#x60;enum&#x60; is used in conjunction with &#x60;oneOf&#x60;, you must keep the set of enumerated values and their order.&lt;br&gt; For example:  &#x60;&#x60;&#x60; \&quot;enum\&quot;: [\&quot;S\&quot;,\&quot;M\&quot;,\&quot;L\&quot;,\&quot;XL\&quot;], \&quot;oneOf\&quot;: [     {\&quot;const\&quot;: \&quot;S\&quot;, \&quot;title\&quot;: \&quot;Small\&quot;},     {\&quot;const\&quot;: \&quot;M\&quot;, \&quot;title\&quot;: \&quot;Medium\&quot;},     {\&quot;const\&quot;: \&quot;L\&quot;, \&quot;title\&quot;: \&quot;Large\&quot;},     {\&quot;const\&quot;: \&quot;XL\&quot;, \&quot;title\&quot;: \&quot;Extra Large\&quot;}   ] &#x60;&#x60;&#x60;
        /// </summary>
        /// <value>Non-empty array of valid JSON schemas.  The &#x60;oneOf&#x60; key is only supported in conjunction with &#x60;enum&#x60; and provides a mechanism to return a display name for the &#x60;enum&#x60; value.&lt;br&gt; Each schema has the following format:  &#x60;&#x60;&#x60; {   \&quot;const\&quot;: \&quot;enumValue\&quot;,   \&quot;title\&quot;: \&quot;display name\&quot; } &#x60;&#x60;&#x60;  When &#x60;enum&#x60; is used in conjunction with &#x60;oneOf&#x60;, you must keep the set of enumerated values and their order.&lt;br&gt; For example:  &#x60;&#x60;&#x60; \&quot;enum\&quot;: [\&quot;S\&quot;,\&quot;M\&quot;,\&quot;L\&quot;,\&quot;XL\&quot;], \&quot;oneOf\&quot;: [     {\&quot;const\&quot;: \&quot;S\&quot;, \&quot;title\&quot;: \&quot;Small\&quot;},     {\&quot;const\&quot;: \&quot;M\&quot;, \&quot;title\&quot;: \&quot;Medium\&quot;},     {\&quot;const\&quot;: \&quot;L\&quot;, \&quot;title\&quot;: \&quot;Large\&quot;},     {\&quot;const\&quot;: \&quot;XL\&quot;, \&quot;title\&quot;: \&quot;Extra Large\&quot;}   ] &#x60;&#x60;&#x60;</value>
        [DataMember(Name = "oneOf", EmitDefaultValue = true)]
        public List<UserSchemaAttributeEnum> OneOf { get; set; }

        /// <summary>
        /// Access control permissions for the property
        /// </summary>
        /// <value>Access control permissions for the property</value>
        [DataMember(Name = "permissions", EmitDefaultValue = true)]
        public List<UserSchemaAttributePermission> Permissions { get; set; }

        /// <summary>
        /// Determines whether the property is required
        /// </summary>
        /// <value>Determines whether the property is required</value>
        [DataMember(Name = "required", EmitDefaultValue = true)]
        public bool? Required { get; set; }

        /// <summary>
        /// User-defined display name for the property
        /// </summary>
        /// <value>User-defined display name for the property</value>
        [DataMember(Name = "title", EmitDefaultValue = true)]
        public string Title { get; set; }

        /// <summary>
        /// Determines whether property values must be unique
        /// </summary>
        /// <value>Determines whether property values must be unique</value>
        [DataMember(Name = "unique", EmitDefaultValue = true)]
        public bool? Unique { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class GroupSchemaBasePropertiesName {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Enum: ").Append(Enum).Append("\n");
            sb.Append("  ExternalName: ").Append(ExternalName).Append("\n");
            sb.Append("  ExternalNamespace: ").Append(ExternalNamespace).Append("\n");
            sb.Append("  Format: ").Append(Format).Append("\n");
            sb.Append("  Items: ").Append(Items).Append("\n");
            sb.Append("  Master: ").Append(Master).Append("\n");
            sb.Append("  MaxLength: ").Append(MaxLength).Append("\n");
            sb.Append("  MinLength: ").Append(MinLength).Append("\n");
            sb.Append("  Mutability: ").Append(Mutability).Append("\n");
            sb.Append("  OneOf: ").Append(OneOf).Append("\n");
            sb.Append("  Permissions: ").Append(Permissions).Append("\n");
            sb.Append("  Required: ").Append(Required).Append("\n");
            sb.Append("  Scope: ").Append(Scope).Append("\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Unique: ").Append(Unique).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as GroupSchemaBasePropertiesName);
        }

        /// <summary>
        /// Returns true if GroupSchemaBasePropertiesName instances are equal
        /// </summary>
        /// <param name="input">Instance of GroupSchemaBasePropertiesName to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(GroupSchemaBasePropertiesName input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.Enum == input.Enum ||
                    this.Enum != null &&
                    input.Enum != null &&
                    this.Enum.SequenceEqual(input.Enum)
                ) && 
                (
                    this.ExternalName == input.ExternalName ||
                    (this.ExternalName != null &&
                    this.ExternalName.Equals(input.ExternalName))
                ) && 
                (
                    this.ExternalNamespace == input.ExternalNamespace ||
                    (this.ExternalNamespace != null &&
                    this.ExternalNamespace.Equals(input.ExternalNamespace))
                ) && 
                (
                    this.Format == input.Format ||
                    this.Format.Equals(input.Format)
                ) && 
                (
                    this.Items == input.Items ||
                    (this.Items != null &&
                    this.Items.Equals(input.Items))
                ) && 
                (
                    this.Master == input.Master ||
                    (this.Master != null &&
                    this.Master.Equals(input.Master))
                ) && 
                (
                    this.MaxLength == input.MaxLength ||
                    (this.MaxLength != null &&
                    this.MaxLength.Equals(input.MaxLength))
                ) && 
                (
                    this.MinLength == input.MinLength ||
                    (this.MinLength != null &&
                    this.MinLength.Equals(input.MinLength))
                ) && 
                (
                    this.Mutability == input.Mutability ||
                    this.Mutability.Equals(input.Mutability)
                ) && 
                (
                    this.OneOf == input.OneOf ||
                    this.OneOf != null &&
                    input.OneOf != null &&
                    this.OneOf.SequenceEqual(input.OneOf)
                ) && 
                (
                    this.Permissions == input.Permissions ||
                    this.Permissions != null &&
                    input.Permissions != null &&
                    this.Permissions.SequenceEqual(input.Permissions)
                ) && 
                (
                    this.Required == input.Required ||
                    (this.Required != null &&
                    this.Required.Equals(input.Required))
                ) && 
                (
                    this.Scope == input.Scope ||
                    this.Scope.Equals(input.Scope)
                ) && 
                (
                    this.Title == input.Title ||
                    (this.Title != null &&
                    this.Title.Equals(input.Title))
                ) && 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.Unique == input.Unique ||
                    (this.Unique != null &&
                    this.Unique.Equals(input.Unique))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.Enum != null)
                {
                    hashCode = (hashCode * 59) + this.Enum.GetHashCode();
                }
                if (this.ExternalName != null)
                {
                    hashCode = (hashCode * 59) + this.ExternalName.GetHashCode();
                }
                if (this.ExternalNamespace != null)
                {
                    hashCode = (hashCode * 59) + this.ExternalNamespace.GetHashCode();
                }
                if (this.Format != null)
                {
                    hashCode = (hashCode * 59) + this.Format.GetHashCode();
                }
                if (this.Items != null)
                {
                    hashCode = (hashCode * 59) + this.Items.GetHashCode();
                }
                if (this.Master != null)
                {
                    hashCode = (hashCode * 59) + this.Master.GetHashCode();
                }
                if (this.MaxLength != null)
                {
                    hashCode = (hashCode * 59) + this.MaxLength.GetHashCode();
                }
                if (this.MinLength != null)
                {
                    hashCode = (hashCode * 59) + this.MinLength.GetHashCode();
                }
                if (this.Mutability != null)
                {
                    hashCode = (hashCode * 59) + this.Mutability.GetHashCode();
                }
                if (this.OneOf != null)
                {
                    hashCode = (hashCode * 59) + this.OneOf.GetHashCode();
                }
                if (this.Permissions != null)
                {
                    hashCode = (hashCode * 59) + this.Permissions.GetHashCode();
                }
                if (this.Required != null)
                {
                    hashCode = (hashCode * 59) + this.Required.GetHashCode();
                }
                if (this.Scope != null)
                {
                    hashCode = (hashCode * 59) + this.Scope.GetHashCode();
                }
                if (this.Title != null)
                {
                    hashCode = (hashCode * 59) + this.Title.GetHashCode();
                }
                if (this.Type != null)
                {
                    hashCode = (hashCode * 59) + this.Type.GetHashCode();
                }
                if (this.Unique != null)
                {
                    hashCode = (hashCode * 59) + this.Unique.GetHashCode();
                }
                return hashCode;
            }
        }

    }

}
