// <copyright company="Okta, Inc">
// Copyright (c) 2014-present Okta, Inc. All rights reserved.
// Licensed under the Apache 2.0 license. See the LICENSE file in the project root for full license information.
// </copyright>

/*
 * Okta Admin Management
 *
 * Allows customers to easily access the Okta Management APIs
 *
 * The version of the OpenAPI document: 5.1.0
 * Contact: devex-public@okta.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using OpenAPIDateConverter = Okta.Sdk.Client.OpenAPIDateConverter;

namespace Okta.Sdk.Model
{
    /// <summary>
    /// Template: ModelGeneric
    /// AuthenticatorMethodOtp
    /// </summary>
    [DataContract(Name = "AuthenticatorMethodOtp")]
    [JsonConverter(typeof(JsonSubtypes), "Type")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodWithVerifiableProperties), "cert")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodWithVerifiableProperties), "duo")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSimple), "email")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodWithVerifiableProperties), "idp")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodOtp), "otp")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSimple), "password")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodPush), "push")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSimple), "security_question")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSignedNonce), "signed_nonce")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSimple), "sms")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodTac), "tac")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodTotp), "totp")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodSimple), "voice")]
    [JsonSubtypes.KnownSubType(typeof(AuthenticatorMethodWebAuthn), "webauthn")]
    
    public partial class AuthenticatorMethodOtp : AuthenticatorMethodWithVerifiableProperties, IEquatable<AuthenticatorMethodOtp>
    {

        /// <summary>
        /// Gets or Sets Algorithm
        /// </summary>
        [DataMember(Name = "algorithm", EmitDefaultValue = true)]
        
        public OtpTotpAlgorithm Algorithm { get; set; }

        /// <summary>
        /// Gets or Sets Encoding
        /// </summary>
        [DataMember(Name = "encoding", EmitDefaultValue = true)]
        
        public OtpTotpEncoding Encoding { get; set; }

        /// <summary>
        /// Gets or Sets Protocol
        /// </summary>
        [DataMember(Name = "protocol", EmitDefaultValue = true)]
        
        public OtpProtocol Protocol { get; set; }
        
        /// <summary>
        /// The number of acceptable adjacent intervals, also known as the clock drift interval. This setting allows you to build in tolerance for any time difference between the token and the server. For example, with a &#x60;timeIntervalInSeconds&#x60; of 60 seconds and an &#x60;acceptableAdjacentIntervals&#x60; value of 5, Okta accepts passcodes within 300 seconds (60 * 5) before or after the end user enters their code.
        /// </summary>
        /// <value>The number of acceptable adjacent intervals, also known as the clock drift interval. This setting allows you to build in tolerance for any time difference between the token and the server. For example, with a &#x60;timeIntervalInSeconds&#x60; of 60 seconds and an &#x60;acceptableAdjacentIntervals&#x60; value of 5, Okta accepts passcodes within 300 seconds (60 * 5) before or after the end user enters their code.</value>
        [DataMember(Name = "acceptableAdjacentIntervals", EmitDefaultValue = true)]
        public int AcceptableAdjacentIntervals { get; set; }

        /// <summary>
        /// The &#x60;id&#x60; value of the factor profile
        /// </summary>
        /// <value>The &#x60;id&#x60; value of the factor profile</value>
        [DataMember(Name = "factorProfileId", EmitDefaultValue = true)]
        public string FactorProfileId { get; set; }

        /// <summary>
        /// Number of digits in an OTP value
        /// </summary>
        /// <value>Number of digits in an OTP value</value>
        [DataMember(Name = "passCodeLength", EmitDefaultValue = true)]
        public int PassCodeLength { get; set; }

        /// <summary>
        /// Time interval for TOTP in seconds
        /// </summary>
        /// <value>Time interval for TOTP in seconds</value>
        [DataMember(Name = "timeIntervalInSeconds", EmitDefaultValue = true)]
        public int TimeIntervalInSeconds { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AuthenticatorMethodOtp {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  AcceptableAdjacentIntervals: ").Append(AcceptableAdjacentIntervals).Append("\n");
            sb.Append("  Algorithm: ").Append(Algorithm).Append("\n");
            sb.Append("  Encoding: ").Append(Encoding).Append("\n");
            sb.Append("  FactorProfileId: ").Append(FactorProfileId).Append("\n");
            sb.Append("  PassCodeLength: ").Append(PassCodeLength).Append("\n");
            sb.Append("  Protocol: ").Append(Protocol).Append("\n");
            sb.Append("  TimeIntervalInSeconds: ").Append(TimeIntervalInSeconds).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AuthenticatorMethodOtp);
        }

        /// <summary>
        /// Returns true if AuthenticatorMethodOtp instances are equal
        /// </summary>
        /// <param name="input">Instance of AuthenticatorMethodOtp to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AuthenticatorMethodOtp input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.AcceptableAdjacentIntervals == input.AcceptableAdjacentIntervals ||
                    this.AcceptableAdjacentIntervals.Equals(input.AcceptableAdjacentIntervals)
                ) && base.Equals(input) && 
                (
                    this.Algorithm == input.Algorithm ||
                    this.Algorithm.Equals(input.Algorithm)
                ) && base.Equals(input) && 
                (
                    this.Encoding == input.Encoding ||
                    this.Encoding.Equals(input.Encoding)
                ) && base.Equals(input) && 
                (
                    this.FactorProfileId == input.FactorProfileId ||
                    (this.FactorProfileId != null &&
                    this.FactorProfileId.Equals(input.FactorProfileId))
                ) && base.Equals(input) && 
                (
                    this.PassCodeLength == input.PassCodeLength ||
                    this.PassCodeLength.Equals(input.PassCodeLength)
                ) && base.Equals(input) && 
                (
                    this.Protocol == input.Protocol ||
                    this.Protocol.Equals(input.Protocol)
                ) && base.Equals(input) && 
                (
                    this.TimeIntervalInSeconds == input.TimeIntervalInSeconds ||
                    this.TimeIntervalInSeconds.Equals(input.TimeIntervalInSeconds)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                
                hashCode = (hashCode * 59) + this.AcceptableAdjacentIntervals.GetHashCode();
                if (this.Algorithm != null)
                {
                    hashCode = (hashCode * 59) + this.Algorithm.GetHashCode();
                }
                if (this.Encoding != null)
                {
                    hashCode = (hashCode * 59) + this.Encoding.GetHashCode();
                }
                if (this.FactorProfileId != null)
                {
                    hashCode = (hashCode * 59) + this.FactorProfileId.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PassCodeLength.GetHashCode();
                if (this.Protocol != null)
                {
                    hashCode = (hashCode * 59) + this.Protocol.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TimeIntervalInSeconds.GetHashCode();
                return hashCode;
            }
        }

    }

}
